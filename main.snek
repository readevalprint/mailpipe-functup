# vim: syntax=python
from uuid import uuid4
import base64
from functup import print, Response, FileResponse, get_channel, APIClient, settings
import html
from django_jsonforms.forms import JSONSchemaForm

from datetime import datetime, timedelta
import arrow
import simplejson as json
from decimal import Decimal
from time import monotonic
from urllib import parse
from requests.exceptions import HTTPError

import re2
from io import BytesIO
from html import escape

client = APIClient()

BTC = Decimal(10 ** 8)

from btcpay import BTCPayClient
import os

UNLIMITED = "UNLIMITED"
FEATURES = {
    "personal": {"max_inboxes": 10},
    "pro": {"max_inboxes": 100, "callback": True},
    "enterprise": {"max_inboxes": UNLIMITED, "custom_mx": True, "callback": True},
}

PLANS = {
    "basic30": {
        "name": "Basic",
        "features": FEATURES["personal"],
        "duration": {"days": 30},
        "price": {"BTC": Decimal("0.00055")},
    },
    "extra30": {
        "name": "Extra",
        "features": FEATURES["pro"],
        "duration": {"days": 30},
        "price": {"BTC": Decimal("0.005")},
        "recommended": True,
    },
    "super30": {
        "name": "Super",
        "features": FEATURES["enterprise"],
        "duration": {"days": 30},
        "price": {"BTC": Decimal("0.033")},
    },
}

for p in PLANS:
    PLANS[p]["price"]["sats"] = PLANS[p]["price"]["BTC"] * BTC


schema_options = {
    "required_by_default": True,
    "theme": "bootstrap4",
    "no_additional_properties": True,
    "disable_collapse": True,
    "disable_edit_json": True,
    "disable_properties": True,
}


def delete_email(email):
    r2 = None
    r2 = client.delete(f"/_emails/{ email }/")
    if r2.status_code == 204:
        return None
    return {"error": [email, r2]}


def delete_message(email, message_uuid):
    r2 = None
    r2 = client.delete(f"/_emails/{ email }/msg/{ message_uuid }/")
    if r2.status_code == 204:
        return None
    return r2.content


def add_email(request):
    email = request.data.get("email").strip()
    user_id = request.user.id
    r = client.post("/_emails/", {"address": email, "user_id": user_id})
    if r.status_code == 201:
        return None
    return r.json()


def get_or_create_profile(user_id):
    path = f"v2/profile/{user_id}"

    profile_res = client.get(f"/_data/{path}")
    if profile_res.status_code == 404:
        data = {"user_id": user_id, "current_plan": None, "next_plan": None}
        profile_res = client.put(f"/_data/{path}", data={"data": data, "path": path})
        if profile_res.status_code != 201:
            raise Exception(profile_res.json())
    profile = profile_res.json()
    TEMPLATE_CONTEXT["balance"] = Decimal(profile["data"].get("balance", 0)) / BTC
    TEMPLATE_CONTEXT["profile"] = profile
    return profile


def update_invoice(user_id, invoice_id):
    btcpayclient = BTCPayClient(
        host=os.environ["BTCPAYSERVER_HOST"],
        pem=os.environ["BTCPAYSERVER_PEM"],
        tokens={"merchant": os.environ["BTCPAYSERVER_TOKEN"]},
    )
    invoice = btcpayclient.get_invoice(invoice_id)
    amount = 0
    if invoice["status"] in ["complete", "confirmed"]:
        amount = max(
            Decimal(invoice["paymentSubtotals"]["BTC"]), Decimal(invoice["amountPaid"])
        )
    return client.patch(
        fr"/_data/v1/transactions/{user_id}/{ invoice_id }",
        data={"data": {"user_id": user_id, "amount": amount, "invoice": invoice}},
    )


def account_info(request, current_usage, profile, errors):
    last_invoice = None
    invoice_link = ""
    result = ""
    user_id = profile["data"]["user_id"]
    transactions = client.get(rf"/_data?path__startswith=v1/transactions/{ user_id }")[
        "json"
    ]["results"]
    balance = Decimal("0")
    for t in transactions:
        balance = balance + Decimal(t["data"].get("amount", 0))
        if "invoice" in t["data"] and t["data"]["invoice"]["status"] == "new":
            last_invoice = t["data"]["invoice"]
            t = update_invoice(profile["data"]["user_id"], last_invoice["id"])["json"]
        if last_invoice:
            invoice_link = f"""
                <div class="alert alert-primary" role="alert">
                  <h3>
                    Your topup invoice is ready</h3> <a href="{last_invoice['url']}">{last_invoice['url']}</a>
                </div>
                """
    result = (
        result
        + rf"""
        <div class="row">
          <div class="col">
            { invoice_link }
            <form action="." method="POST" class="form-inline">
              <label for="amount">Amount</label>
              <div class="form-group  mx-sm-3 mb-1">
                <input name="amount"  id="amount" class="form-control { "is-invalid" if 'amount' in errors else ""  }" value="{ request['data'].get('amount', '') }">
                { 'amount' in errors and rf'''
                <div class="invalid-tooltip">
                  { errors['amount'] }
                </div>
                ''' or " " }
              </div>
              { csrf_input }
              <button type="submit" class="btn btn-primary mb-2"  {'disabled' if invoice_link else ''}>Top up</button>
            </form>
          </div>
        </div>
    """
    )

    result = (
        result
        + rf"""
    <div class="row">
        <div class="col">
            <p>
                Current balance: { '%.8f' % (balance / BTC) } BTC </br>
                Addresses: { current_usage['num_addresses'] } @ { '%.8f' % (current_usage['sats_per_address'] / BTC) } BTC/day <br>
                Data usage: { int(current_usage['messege_length_sum'] / 1000) }KB @ { current_usage['sats_per_byte']  } sat/byte <br>
                Next billing cycle: { current_usage['next_billing_cycle'].humanize() } <br>
                Estimated billing amount: { '%.8f' % (current_usage['sats_total'] / BTC)  } BTC <br>
            </p>
        </div>
    </div>
    """
    )

    return result


def topup_view(request):
    user_id = request.user.id
    if not user_id:
        return Response(status=302, headers={"Location": "/"})
    profile = get_or_create_profile(user_id)
    errors = {}

    schema = {
        "title": "Top up account credit",
        "type": "object",
        "properties": {
            "amount": {
                "type": "number",
                "title": "Amount",
                "description": "Amount to generate a new invoice for",
                "minimum": 0.00001,
                "maximum": 0.1,
            }
        },
    }
    if request.method == "OPTIONS":
        return Response({"schema": schema}, template_name="rest_framework_base.html")
    TEMPLATE_CONTEXT["schema"] = schema
    form = JSONSchemaForm(
        data=request.data or None, schema=schema, options=schema_options, ajax=False
    )

    TEMPLATE_CONTEXT["form"] = form

    data = {}
    if request.method == "POST":
        if form.is_valid():
            btcpayclient = BTCPayClient(
                host=os.environ["BTCPAYSERVER_HOST"],
                pem=os.environ["BTCPAYSERVER_PEM"],
                tokens={"merchant": os.environ["BTCPAYSERVER_TOKEN"]},
            )
            amount = form.cleaned_data["json"]["amount"]
            invoice = btcpayclient.create_invoice(
                {
                    "price": amount,
                    "currency": "BTC",
                    "redirectURL": "https://" + settings["DOMAIN"],
                    "itemDescription": "top up",
                    "notificationURL": rf"https://{settings['DOMAIN']}/update_invoice/",
                }
            )
            client.post(
                r"/_data",
                data={
                    "path": rf'v1/transactions/{user_id}/{ invoice["id"] }',
                    "data": {"invoice": invoice, "user_id": user_id},
                },
            )
            data = {
                "invoice_url": invoice["url"],
                "invoice_id": invoice["id"],
                "expiration_time": invoice["expirationTime"],
                "addresses": invoice["addresses"],
            }
            if request.accepted_renderer.format == "html":
                return Response(status=302, headers={"Location": invoice["url"]})
            # r = client.patch(profile["url"], data={"data": profile["data"]})
            # if r.status_code == 200:

            #    data = invoice
            # else:
            #    data = j.json()
    new_invoices_res = client.get(
        f"/_data?path__startswith=v1/transactions/{ user_id }/&data__invoice__status=new"
    )
    new_invoices = [
        update_invoice(i["data"]["invoice"]["id"])
        for i in new_invoices_res.json()["results"]
    ]
    if request.accepted_renderer.format == "json":
        if form.errors:
            data = form.errors.get_json_data()
    if request.accepted_renderer.format == "html":
        if any(new_invoices):
            new_invoices_res = client.get(
                f"/_data?path__startswith=v1/transactions/{ user_id }/&data__invoice__status=new"
            )
            new_invoices = new_invoices_res.json()["results"]
            TEMPLATE_CONTEXT["new_invoices"] = new_invoices
    return Response(data, template_name="topup.html")


def update_invoice_view(request):
    invoice_id = request.data.get("id", None) or request.query_params.get(
        "invoice_id", "1111"
    )
    print("updating invoice")
    print(invoice_id)
    return Response(update_invoice(invoice_id))


def update_invoice(invoice_id):
    btcpayclient = BTCPayClient(
        host=os.environ["BTCPAYSERVER_HOST"],
        pem=os.environ["BTCPAYSERVER_PEM"],
        tokens={"merchant": os.environ["BTCPAYSERVER_TOKEN"]},
    )
    data = None
    try:
        invoice = btcpayclient.get_invoice(invoice_id)
        r = client.get(f"/_data?data__invoice__id={ invoice_id }")
        if r.status_code == 200 and r.json()["count"] == 1:
            d = r.json()
            transaction = r.json()["results"][0]
            transaction["data"]["invoice"] = invoice
            transaction["data"]["amount_sats"] = int(Decimal(invoice["btcPaid"]) * BTC)
            r = client.patch(transaction["url"], data=transaction)
            print(r.status_code)
            data = invoice

    except Exception as e:
        print("Oh no")
        print(e)
    return data


STATIC_URL = "/static/"


def welcome_view(request):
    TEMPLATE_CONTEXT["plans"] = PLANS
    return Response({}, template_name="index.html")


def email_list_view(request):
    user_id = request.user.id
    if not user_id:
        return Response(status=302, headers={"Location": "/welcome/"})
    # should only be one but you never know
    profile = get_or_create_profile(user_id)
    errors = {}
    # next_page = f"/_data?data__owner={request.user.username}&path__startswith=v1/emails&page_size=10000"
    # next_page = False
    # while next_page:
    #    old_data_resp = client.get(next_page)
    #    old_address_list = old_data_resp.json()["results"]
    #    for oa in old_address_list:
    #        r = client.patch(f"/_emails/{oa['data']['email']}/", {"user_id": user_id})
    #        client.delete(oa["url"])
    #    next_page = old_data_resp.json()["next"]

    data = user_email_list(request, user_id)
    schema = {
        "title": "Create new inbox",
        "type": "object",
        "format": "grid",
        "properties": {
            "address": {
                "type": "string",
                "title": "Inbox email address",
                "description": "Email address you want to receive email to",
                "format": "email",
            },
            "callback_url": {
                "type": "string",
                "title": "Callback URL",
                "description": "Public url that will receive notification on new emails",
                "minLength": 0,
                "default": "",
                "format": "uri",
                "pattern": "^(https|http)://.*|",
            },
        },
    }
    TEMPLATE_CONTEXT["schema"] = schema
    if request.method == "OPTIONS":
        return Response({"schema": schema}, template_name="rest_framework_base.html")

    form = JSONSchemaForm(
        data=request.data or None, schema=schema, options=schema_options, ajax=False
    )

    TEMPLATE_CONTEXT["form"] = form
    if request.method == "POST":
        if (
            data["count"]
            < (
                profile["data"].get("current_plan", None)
                or {"features": {"max_inboxes": 1}}
            )["features"]["max_inboxes"]
        ):
            if form.is_valid():
                r = client.post(
                    "/_emails/",
                    data={
                        "callback_url": form.cleaned_data["json"]["callback_url"],
                        "address": form.cleaned_data["json"]["address"],
                        "user_id": user_id,
                    },
                )
                if r.status_code == 201:
                    email_data = email_adapter(request, r.json())
                    return Response(status=302, headers={"Location": request.path})
                else:
                    for k, v in r.json().items():
                        if k in form.fields:
                            form.add_error(k, v)
                        else:
                            form.add_error(None, v)
        else:
            form.add_error(
                None,
                "You have used all your avalible inboxes. Please upgrade your plan or delete an existing inbox.",
            )

    if request.accepted_renderer.format == "json":
        if form.errors:
            data = form.errors.get_json_data()

    return Response(data, template_name="email_list.html")


def delete(request, email):
    if not request.user.id:
        return Response(
            base(
                request=request,
                title="Login",
                body="hi there stranger, why don't you log in?",
            )
        )

    if request.method == "POST":
        if not error:
            return Response(status=302, headers={"location": "/"})
        return Response(error, status=400)


def attachment_detail(request, email_address, message_uuid, attachment_index, filename):
    if not request.user.id:
        return Response(
            f"""<html><a href="/_login?next={ request.path }"> Log in required.</a>"""
        )

    user_id = request.user.id
    url = rf"/_emails/?user_id={user_id}&" + parse.urlencode(
        {"address": email_address}, safe="@"
    )
    j = client.get(url).json()
    if not j["count"] != "1":
        return Response("ohno, not found", status=404)
    message = client.get(f"/_emails/{email_address}/msg/{message_uuid}/").json()
    attachment = message["attachments"][int(attachment_index)]

    r = client.get(
        f"/_emails/{email_address}/msg/{message_uuid}/attachments/{attachment_index}/{filename}"
    )
    # print(path)
    # print(f"/_data/static/{path}?format=file")
    if r.status_code == 200:
        return Response(
            r.content,
            content_type=r["content-type"],
            headers={
                "Cache-Control": "public, max-age=31536001",
                "Expires": (datetime.now() + timedelta(days=10)).strftime(
                    "%a %d %b %Y %H:%M:%S%f GMT"
                ),
            },
        )
    return Response(r.content, status=404)


def message_list_view(request, email_address):
    if not request.user.id:
        return Response(
            f"""<html><a href="/_login?next={ request.path }"> Log in required.</a>"""
        )
    user_id = request.user.id
    url = rf"/_emails/?user_id={user_id}&" + parse.urlencode(
        {"address": email_address}, safe="@"
    )
    j = client.get(url).json()
    if not j["count"] != "1":
        return Response("uh oh, not found", status=404)
    email_data = j["results"][0]
    TEMPLATE_CONTEXT["email"] = email_data
    d = {}
    page = request.query_params.get("page")
    if page:
        d["page"] = page
    page_size = request.query_params.get("page_size", None)
    if page_size:
        d["page_size"] = page_size

    url = email_data["messages"] + "?" + parse.urlencode(d)
    j = client.get(url).json()
    j = page_adapter(request, j, f"/{email_address}/messages/")
    j = page_result_adapter(request, j, email_message_adapter)
    return Response(j, template_name="message_list.html")


def message_detail_view(request, email_address, message_uuid):
    if not request.user.id:
        return Response(
            f"""<html><a href="/_login?next={ request.path }"> Log in required.</a>"""
        )

    user_id = request.user.id
    url = rf"/_emails/?user_id={user_id}&" + parse.urlencode(
        {"address": email_address}, safe="@"
    )
    j = client.get(url).json()
    if j["count"] != 1:
        return Response("ohno, not found", status=404)
    r = client.get(f"/_emails/{email_address}/msg/{message_uuid}/")
    message = r.json()
    if r.status_code != 200:
        return Response(
            message, status=r.status_code, template_name="message_detail.html"
        )
    if request.method == "DELETE" or "delete" in request.data:
        error = delete_message(email_address, message_uuid)
        if not error:
            # todo just show deleted confirmation
            return Response(
                status=302, headers={"location": fr"/{ email_address }/messages/"}
            )
        return Response(error)

    return Response(
        email_message_adapter(request, message), template_name="message_detail.html"
    )


def owns_email(user_id, email):
    email_resp = client.get(f"/_emails/{email}/")
    if email_resp["status_code"] != 200 or email_resp["json"]["user_id"] != user_id:
        return False
    return email_resp["json"]


def email_detail_view(request, email_address):
    user_id = request.user.id
    if not user_id:
        return Response(
            f"""<html><a href="/_login?next={ request.path }"> Log in required.</a>"""
        )

    url = rf"/_emails/?user_id={user_id}&" + parse.urlencode(
        {"address": email_address}, safe="@"
    )
    print(url)
    j = client.get(url).json()
    if j["count"] == 1:
        internal_data = j["results"][0]
        email_data = email_adapter(request, internal_data)
    else:
        return Response("not found", status=404)

    schema = {
        "title": "Update Email settings",
        "type": "object",
        "properties": {
            "callback_url": {
                "type": "string",
                "title": "Callback URL",
                "description": "Public url that will receive notification on new emails",
                "minLength": 0,
                "default": "",
                "format": "uri",
                "pattern": "^(https|http)://.*|",
            }
        },
    }
    TEMPLATE_CONTEXT["schema"] = schema

    if request.method == "OPTIONS":
        return Response({"schema": schema}, template_name="rest_framework_base.html")

    form = JSONSchemaForm(
        data=request.data or {"json": json.dumps(email_data)},
        schema=schema,
        options=schema_options,
        ajax=False,
    )

    TEMPLATE_CONTEXT["form"] = form
    if "delete" in request.data or request.method == "DELETE":
        error = delete_email(email_address)
        if not error:
            return Response(status=302, headers={"location": "/"})
        form.add_error(None, error)
    elif request.method == "POST":
        if form.is_valid():
            r = client.patch(
                internal_data["url"],
                data={"callback_url": form.cleaned_data["json"]["callback_url"]},
            )
            if r.status_code == 200:
                return Response(status=302, headers={"location": email_data["url"]})
            else:
                for k, v in r.json().items():
                    if k in form.fields:
                        form.add_error(k, v)
                    else:
                        form.add_error(None, v)

    if request.accepted_renderer.format == "json":
        if form.errors:
            email_data = form.errors.get_json_data()
    return Response(email_data, template_name="email_detail.html")


def email_attachment_adapter(request, e, a):
    r = a
    r["attachment_url"] = request.build_absolute_uri(
        f"/{e['account']}/messages/{e['uuid']}/{a['index']}/{a['filename']}"
    )
    return r


def email_message_adapter(request, e):
    r = {}
    r["url"] = request.build_absolute_uri(
        "/" + e["account"] + f"/messages/{e['uuid']}/"
    )
    r["frm"] = e["frm"]
    r["to"] = e["to"]
    r["subject"] = e["subject"]
    r["text"] = e["text"]
    r["html"] = e["html"]
    r["attachments"] = [
        email_attachment_adapter(request, e, a) for a in e["attachments"]
    ]
    r["account"] = e["account"]
    r["created_at"] = e["created_at"]

    if "format" in request.query_params:
        r["url"] = r["url"] + "?format=" + request.query_params["format"]
    return r


def email_adapter(request, e):
    r = {}
    r["url"] = request.build_absolute_uri("/" + e["address"] + "/")
    r["address"] = e["address"]
    r["messages"] = request.build_absolute_uri("/" + e["address"] + "/messages/")
    r["message_count"] = e.get("message_count")
    r["messege_length_sum"] = e.get("messege_length_sum")
    r["callback_url"] = e["callback_url"]

    if request.query_params.get("format"):
        r["url"] = r["url"] + "?format=" + request.query_params["format"]
        r["messages"] = r["messages"] + "?format=" + request.query_params["format"]
    return r


def user_email_list(request, user_id):
    d = {}
    page = request.query_params.get("page")
    if page:
        d["page"] = page
    page_size = request.query_params.get("page_size", None)
    if page_size:
        d["page_size"] = page_size

    url = rf"/_emails/?user_id={user_id}&" + parse.urlencode(d)
    j = client.get(url).json()
    j = page_adapter(request, j, "/")
    j = page_result_adapter(request, j, email_adapter)
    return j


def user_email_detail(request, user_id, email_address):
    url = rf"/_emails/?user_id={user_id}&" + parse.urlencode(
        {"address": email_address}, safe="@"
    )
    print(url)
    j = client.get(url).json()
    if j["count"] == 1:
        return j["results"][0], email_adapter(request, j["results"][0])
    return None


def page_adapter(request, j, path):
    if j.get("next"):
        qs = parse.urlsplit(j["next"]).query
        qs_dict = parse.parse_qs(qs)
        qs_dict = dict((k, qs_dict[k]) for k in ("page", "page_size") if k in qs_dict)
        if request.query_params.get("format"):
            qs_dict["format"] = request.query_params["format"]
        j["next"] = (
            request.build_absolute_uri(path)
            + "?"
            + parse.urlencode(qs_dict, doseq=True)
        )
    if j.get("previous"):
        qs = parse.urlsplit(j["previous"]).query
        qs_dict = parse.parse_qs(qs)
        qs_dict = dict((k, qs_dict[k]) for k in ("page", "page_size") if k in qs_dict)
        if "format" in request.query_params:
            qs_dict["format"] = request.query_params["format"]
        j["previous"] = (
            request.build_absolute_uri(path)
            + "?"
            + parse.urlencode(qs_dict, doseq=True)
        )
    return j


def page_result_adapter(request, j, func):
    j["results"] = [func(request, r) for r in j.get("results", [])]
    return j


def get_current_usage(emails):
    num_addresses = len(emails)
    messege_length_sum = 0
    message_count = 0
    for e in emails:
        message_count = message_count + e["message_count"]
        messege_length_sum = messege_length_sum + e["messege_length_sum"]

    present = arrow.utcnow()
    return {
        "num_addresses": num_addresses,
        "message_count": message_count,
        "messege_length_sum": messege_length_sum,
        "current_billing_cycle": present.replace(
            hour=0, minute=0, second=0, microsecond=0
        ),
        "next_billing_cycle": present.replace(
            hour=0, minute=0, second=0, microsecond=0
        ).shift(hours=24),
        "sats_per_message": RATE["sats_per_message"],
        "sats_per_address": RATE["sats_per_address"],
        "sats_per_byte": RATE["sats_per_byte"],
        "sats_total": (
            Decimal(message_count * RATE["sats_per_message"])
            + Decimal(num_addresses * RATE["sats_per_address"])
            + Decimal(messege_length_sum * RATE["sats_per_byte"])
        ),
    }


def bill_users(request):
    if request["user"]["id"] != settings["OWNER"]["id"]:
        return Response("no")

    profiles = client.get("/_data?path__startswith=v2/profile")["json"]["results"]
    r = []
    for profile in profiles:
        r = r + [bill_user(profile)]
    return Response(json.dumps(r, indent=2), content_type="json")


def bill_user(profile):
    user_id = profile["url"].split("/")[-1]
    emails = user_email_list(user_id)
    current_usage = get_current_usage(emails)
    current_usage["current_billing_cycle"] = current_usage[
        "current_billing_cycle"
    ].timestamp
    current_usage["next_billing_cycle"] = current_usage["next_billing_cycle"].timestamp
    r = client.post(
        r"/_data",
        data=json.loads(
            json.dumps(
                {
                    "path": rf'v1/transactions/{user_id}/{ current_usage["current_billing_cycle"] }',
                    "data": {
                        "amount": -current_usage["sats_total"],
                        "current_usage": current_usage,
                    },
                }
            )
        ),
    )
    return r["json"]


def static(request, path):
    r = client.get(f"/_data/static/{path}?format=file")
    # print(path)
    # print(f"/_data/static/{path}?format=file")
    if r.status_code == 200:
        return Response(
            r.content,
            content_type=r.content_type,
            headers={
                "Cache-Control": "public, max-age=31536001",
                "Expires": (datetime.now() + timedelta(days=10)).strftime(
                    "%a %d %b %Y %H:%M:%S%f GMT"
                ),
            },
        )
    return Response(r.content, status=404)


def transaction_adaptor(request, t):
    d = {
        "created": t["created"],
        "updated": t["updated"],
        "amount": Decimal(t["data"].get("amount_sats", 0)) / BTC,
    }
    if "plan" in t["data"]:
        d[
            "info"
        ] = f"Purchase  {t['data']['plan']['features']['max_inboxes'] } inboxes for { ' '.join(t['data']['plan']['duration'].items()) } "

    if "invoice" in t["data"]:
        d["info"] = "Balance topup"
        d["invoice_url"] = t["data"]["invoice"]["url"]
        d["invoice_id"] = t["data"]["invoice"]["id"]
        d["invoice_price"] = t["data"]["invoice"]["price"]
        d["status"] = t["data"]["invoice"]["status"]

    if "rebated_plan" in t["data"]:
        d["info"] = "Rebate for remaining time"

    return d


def transaction_view(request):
    user_id = request.user.id
    if not user_id:
        return Response(
            f"""<html><a href="/_login?next={ request.path }"> Log in required.</a>"""
        )
    profile = get_or_create_profile(user_id)
    page = request.query_params.get("page", None)
    d = {}
    if page:
        d["page"] = page
    page_size = request.query_params.get("page_size", None)
    if page_size:
        d["page_size"] = page_size
    d["path__startswith"] = f"v1/transactions/{user_id}"
    url = f"/_data?" + parse.urlencode(d)
    r = client.get(url)
    data = []
    if r.status_code == 200:
        data = r.json()

    balance = 0
    for t in data.get("results", []):
        balance = balance + t["data"].get("amount_sats", 0)

    profile["data"]["balance"] = balance
    client.patch(profile["url"], data={"data": profile["data"]})

    profile = get_or_create_profile(user_id)
    data = page_adapter(request, data, "/transactions/")
    data = page_result_adapter(request, data, transaction_adaptor)
    return Response(data, template_name="transaction_list.html")


def plan_view(request, selected_plan):
    if not selected_plan or (selected_plan not in PLANS):
        for k, p in PLANS.items():
            if p.get("recommended"):
                return Response(status=302, headers={"Location": f"/plans/{k}/"})

    user_id = request.user.id
    if not user_id:
        return Response(
            status=302, headers={"Location": f"/_login?lazy&next={request.path}"}
        )
    profile = get_or_create_profile(user_id)
    schema = {"type": "string", "enum": list(PLANS.keys())}
    TEMPLATE_CONTEXT["schema"] = schema
    TEMPLATE_CONTEXT["plans"] = PLANS

    if request.method == "OPTIONS":
        return Response({"schema": schema}, template_name="rest_framework_base.html")

    data = {}
    form = JSONSchemaForm(
        data=request.data or None, schema=schema, options=schema_options, ajax=False
    )

    TEMPLATE_CONTEXT["form"] = form

    if request.method == "POST":
        if form.is_valid():
            print("valid")
            present = arrow.utcnow()
            current_plan = profile["data"].get("current_plan", None)
            rebate_amount = 0
            if current_plan:
                current_start = arrow.get(current_plan["start"])
                current_end = arrow.get(current_plan["end"])
                rebate_amount = current_plan["price"]["sats"] * (
                    (current_end - present) / (current_end - current_start)
                )
            new_plan = PLANS[form.cleaned_data["json"]]
            if (
                rebate_amount + profile["data"].get("balance", 0)
                >= new_plan["price"]["sats"]
            ):
                print("adding plan")
                print(new_plan)
                new_plan["start"] = present.isoformat()
                new_plan["end"] = present.shift(**new_plan["duration"]).isoformat()
                profile["data"]["current_plan"] = new_plan
                client.patch(profile["url"], data={"data": profile["data"]})

                # add rebate if needed
                if rebate_amount > 0:
                    r = client.post(
                        r"/_data",
                        data={
                            "path": rf"v1/transactions/{user_id}/{ uuid4() }",
                            "data": {
                                "amount_sats": rebate_amount,
                                "rebated_plan": current_plan,
                                "user_id": user_id,
                            },
                        },
                    )
                # make new current plan
                r = client.post(
                    r"/_data",
                    data={
                        "path": rf"v1/transactions/{user_id}/{ uuid4() }",
                        "data": {
                            "amount_sats": -new_plan["price"]["sats"],
                            "plan": new_plan,
                            "user_id": user_id,
                        },
                    },
                )
            else:
                form.add_error(None, "insufficient balance")

    if request.accepted_renderer.format == "json":
        if form.errors:
            data = form.errors.get_json_data()
        else:
            data = invoice
    return Response(data, template_name="plans.html")


urls = [
    (r"/welcome/$", welcome_view),
    (r"/$", email_list_view),
    (r"/(?P<email_address>[^/]+@[^/]+.[^/])/$", email_detail_view),
    (r"/(?P<email_address>[^/]+@[^/]+.[^/])/messages/$", message_list_view),
    (
        r"/(?P<email_address>[^/]+@[^/]+.[^/])/messages/(?P<message_uuid>[^/]+)/$",
        message_detail_view,
    ),
    (
        r"/(?P<email_address>[^/]+@[^/]+.[^/])/messages/(?P<message_uuid>[^/]+)/(?P<attachment_index>[0-9]+)/(?P<filename>.+)$",
        attachment_detail,
    ),
    (r"/topup/", topup_view),
    (r"/transactions/", transaction_view),
    (r"/update_invoice/", update_invoice_view),
    (r"/plans/(?P<selected_plan>[a-z0-9]*)/", plan_view),
    (r"/static/(?P<path>.*)$", static),
]


def handle(request):
    if request.domain != settings["DOMAIN"]:
        return Response({"content": "not found"}, status=404, template_name="base.html")

    for path_re, view in urls:
        m = re2.match(path_re, request.path)
        if m:
            return view(request, **m.groupdict())

    for path_re, view in urls:
        m = re2.match(path_re, request.path + "/")
        if m:
            location = request.path + "/"
            if request.query_params:
                location = location + "?" + parse.urlencode(request.query_params)

            return Response(status=302, headers={"location": location})
    return Response({"content": "not found"}, status=404, template_name="base.html")


get = handle
post = handle
delete = handle

options = handle


# global store for things we want in the html, but are not the core data

TEMPLATE_CONTEXT = {}


def add_template_context(request):
    return TEMPLATE_CONTEXT


def add_user_context(request):
    return {"user": request.user}


CONTEXT_PROCESSORS = [add_template_context, add_user_context]


def test_home():
    resp = handle({"path": "/", "user": {"username": "", "id": None}})
    resp = handle({"path": "/", "user": {"username": "bob2", "id": 2}})


def test_emails():
    resp = handle({"path": "/e/foo@example.com"})


def test_404():
    resp = handle({"path": "/non-existant"})
