# vim: syntax=python

import base64
from functup import print, Response, FileResponse, get_channel, APIClient, settings
import html
from django_jsonforms.forms import JSONSchemaForm

from datetime import datetime, timedelta
import arrow
import simplejson as json
from decimal import Decimal
from time import monotonic
from urllib import parse

import re2
from io import BytesIO
from html import escape

client = APIClient()

RATE = {"sats_per_address": 10000, "sats_per_byte": 1, "sats_per_message": 0}
BTC = Decimal(10 ** 8)

from btcpay import BTCPayClient
import os

# btcpayclient = BTCPayClient(
#    host=os.environ["BTCPAYSERVER_HOST"),
#    pem=os.environ["BTCPAYSERVER_PEM"],
#    tokens={"merchant": os.environ["BTCPAYSERVER_TOKEN"]},
# )

schema_options = {
    "required_by_default": True,
    "theme": "bootstrap2",
    "no_additional_properties": True,
    "disable_collapse": True,
    "disable_edit_json": True,
    "disable_properties": True,
}


def delete_email(email):
    r2 = None
    r2 = client.delete(f"/_emails/{ email }/")
    if r2["status_code"] == 204:
        return None
    return {"error": [email, r2]}


def delete_message(email, message_uuid):
    r2 = None
    r2 = client.delete(f"/_emails/{ email }/msg/{ message_uuid }/")
    if r2["status_code"] == 204:
        return None
    return {"error": [email, r2]}


def add_email(request):
    email = request.data.get("email").strip()
    user_id = request.user.id
    r = client.post("/_emails/", {"address": email, "user_id": user_id})
    if r.status_code == 201:
        return None
    return r.json()


def get_or_create_profile(user_id):
    profile_res = client.get(f"/_data/v2/profile/{user_id}")
    if profile_res.status_code == 200:
        return profile_res.json
    profile_res = client.get(f"/_data/v1/profile/{user_id}")
    data = profile_res["json"]["data"]
    data["user_id"] = user_id
    profile = client.post(
        "/_data", data={"path": f"v2/profile/{user_id}", "data": data}
    )["json"]
    bill_user(profile)
    return profile


def update_invoice(user_id, invoice_id):
    invoice = btcpayclient.get_invoice(invoice_id)
    amount = 0
    if invoice["status"] in ["complete", "confirmed"]:
        amount = max(
            Decimal(invoice["paymentSubtotals"]["BTC"]), Decimal(invoice["amountPaid"])
        )
    return client.patch(
        fr"/_data/v1/transactions/{user_id}/{ invoice_id }",
        data={"data": {"user_id": user_id, "amount": amount, "invoice": invoice}},
    )


def account_info(request, current_usage, profile, errors):
    last_invoice = None
    invoice_link = ""
    result = ""
    user_id = profile["data"]["user_id"]
    transactions = client.get(rf"/_data?path__startswith=v1/transactions/{ user_id }")[
        "json"
    ]["results"]
    balance = Decimal("0")
    for t in transactions:
        balance = balance + Decimal(t["data"].get("amount", 0))
        if "invoice" in t["data"] and t["data"]["invoice"]["status"] == "new":
            last_invoice = t["data"]["invoice"]
            t = update_invoice(profile["data"]["user_id"], last_invoice["id"])["json"]
        if last_invoice:
            invoice_link = f"""
                <div class="alert alert-primary" role="alert">
                  <h3>
                    Your topup invoice is ready</h3> <a href="{last_invoice['url']}">{last_invoice['url']}</a>
                </div>
                """
    result = (
        result
        + rf"""
        <div class="row">
          <div class="col">
            { invoice_link }
            <form action="." method="POST" class="form-inline">
              <label for="amount">Amount</label>
              <div class="form-group  mx-sm-3 mb-1">
                <input name="amount"  id="amount" class="form-control { "is-invalid" if 'amount' in errors else ""  }" value="{ request['data'].get('amount', '') }">
                { 'amount' in errors and rf'''
                <div class="invalid-tooltip">
                  { errors['amount'] }
                </div>
                ''' or " " }
              </div>
              { csrf_input }
              <button type="submit" class="btn btn-primary mb-2"  {'disabled' if invoice_link else ''}>Top up</button>
            </form>
          </div>
        </div>
    """
    )

    result = (
        result
        + rf"""
    <div class="row">
        <div class="col">
            <p>
                Current balance: { '%.8f' % (balance / BTC) } BTC </br>
                Addresses: { current_usage['num_addresses'] } @ { '%.8f' % (current_usage['sats_per_address'] / BTC) } BTC/day <br>
                Data usage: { int(current_usage['messege_length_sum'] / 1000) }KB @ { current_usage['sats_per_byte']  } sat/byte <br>
                Next billing cycle: { current_usage['next_billing_cycle'].humanize() } <br>
                Estimated billing amount: { '%.8f' % (current_usage['sats_total'] / BTC)  } BTC <br>
            </p>
        </div>
    </div>
    """
    )

    return result


def topup(request, user_id, profile):
    amount = request["data"].get("amount", None) or request["query_params"].get(
        "amount", "0"
    )
    amount = float(amount.strip())
    if amount < 0.00001 or amount > 0.1:
        return {"amount": "Amount must be between 0.1 and 0.00001"}
    invoice = btcpayclient.create_invoice(
        {
            "price": amount,
            "currency": "BTC",
            "redirectURL": "https://" + settings["DOMAIN"],
            "itemDescription": "top up",
        }
    )
    client.post(
        r"/_data",
        data={
            "path": rf'v1/transactions/{user_id}/{ invoice["id"] }',
            "data": {"amount": 0, "invoice": invoice},
        },
    )
    r = client.patch(profile["url"], data={"data": profile["data"]})
    if r["status_code"] == 200:
        return None
    return r["json"]


STATIC_URL = "/static/"


def home(request):
    user_id = request.user.id
    if not user_id:
        return Response({}, template_name="index.html")
    # should only be one but you never know
    profile = get_or_create_profile(user_id)
    errors = {}
    if request.method == "POST":
        if "email" in request.data:
            errors = add_email(request)
            if not errors:
                return Response(status=302, headers={"location": "/"})
        if "amount" in request.data:
            errors = topup(request, user_id, profile)
            if not errors:
                return Response(status=302, headers={"location": "/"})

    next_page = f"/_data?data__owner={request.user.username}&path__startswith=v1/emails&page_size=10000"
    # next_page = False
    while next_page:
        old_data_resp = client.get(next_page)
        old_address_list = old_data_resp.json()["results"]
        for oa in old_address_list:
            r = client.patch(f"/_emails/{oa['data']['email']}/", {"user_id": user_id})
            client.delete(oa["url"])
        next_page = old_data_resp.json()["next"]

    emails = user_email_list(request, user_id)
    # current_usage = get_current_usage(emails)
    return Response(emails, template_name="email_list.html")


def delete(request, email):
    if not request.user.id:
        return Response(
            base(
                request=request,
                title="Login",
                body="hi there stranger, why don't you log in?",
            )
        )

    if request.method == "POST":
        if not error:
            return Response(status=302, headers={"location": "/"})
        return Response(error, status=400)


def attachment_detail(request, email_address, message_uuid, attachment_index, filename):
    if not request.user.id:
        return Response(
            f"""<html><a href="/_login?next={ request.path }"> Log in required.</a>"""
        )

    user_id = request.user.id
    url = rf"/_emails/?user_id={user_id}&" + parse.urlencode(
        {"address": email_address}, safe="@"
    )
    j = client.get(url).json()
    if not j["count"] != "1":
        return Response("ohno, not found", status=404)
    message = client.get(f"/_emails/{email_address}/msg/{message_uuid}/").json()
    attachment = message["attachments"][int(attachment_index)]

    r = client.get(
        f"/_emails/{email_address}/msg/{message_uuid}/attachments/{attachment_index}/{filename}"
    )
    # print(path)
    # print(f"/_data/static/{path}?format=file")
    if r.status_code == 200:
        return Response(
            r.content,
            content_type=r["content-type"],
            headers={
                "Cache-Control": "public, max-age=31536001",
                "Expires": (datetime.now() + timedelta(days=10)).strftime(
                    "%a %d %b %Y %H:%M:%S%f GMT"
                ),
            },
        )
    return Response(r.content, status=404)


def message_list_view(request, email_address):
    if not request.user.id:
        return Response(
            f"""<html><a href="/_login?next={ request.path }"> Log in required.</a>"""
        )
    user_id = request.user.id
    url = rf"/_emails/?user_id={user_id}&" + parse.urlencode(
        {"address": email_address}, safe="@"
    )
    j = client.get(url).json()
    if not j["count"] != "1":
        return Response("uh oh, not found", status=404)
    data = j["results"][0]
    d = {}
    page = request.query_params.get("page")
    if page:
        d["page"] = page
    page_size = request.query_params.get("page_size", None)
    if page_size:
        d["page_size"] = page_size

    url = data["messages"] + "?" + parse.urlencode(d)
    j = client.get(url).json()
    j = page_adapter(request, j, f"/{email_address}/messages/")
    j = page_result_adapter(request, j, email_message_adapter)
    return Response(j, template_name='message_list.html')


def message_detail_view(request, email_address, message_uuid):
    if not request.user.id:
        return Response(
            f"""<html><a href="/_login?next={ request.path }"> Log in required.</a>"""
        )

    user_id = request.user.id
    url = rf"/_emails/?user_id={user_id}&" + parse.urlencode(
        {"address": email_address}, safe="@"
    )
    j = client.get(url).json()
    if j["count"] != 1:
        return Response("ohno, not found", status=404)
    message = client.get(f"/_emails/{email_address}/msg/{message_uuid}/").json()
    print(message)
    if request.method == "DELETE" or "delete" in request.data:
        error = delete_message(email, message_uuid)
        if not error:
            # todo just show deleted confirmation
            return Response(status=302, headers={"location": fr"/{ email }/messages/"})
        return Response(error)

    return Response(email_message_adapter(request, message))


def owns_email(user_id, email):
    email_resp = client.get(f"/_emails/{email}/")
    if email_resp["status_code"] != 200 or email_resp["json"]["user_id"] != user_id:
        return False
    return email_resp["json"]


def email_detail_view(request, email_address):
    user_id = request.user.id
    if not user_id:
        return Response(
            f"""<html><a href="/_login?next={ request.path }"> Log in required.</a>"""
        )

    url = rf"/_emails/?user_id={user_id}&" + parse.urlencode(
        {"address": email_address}, safe="@"
    )
    print(url)
    j = client.get(url).json()
    internal_data = j["results"][0]
    if j["count"] == 1:
        email_data = email_adapter(request, internal_data)
    if not email_data:
        return Response("not found", status=404)

    schema = {
        "title": "Update Email settings",
        "type": "object",
        "properties": {
            "callback_url": {
                "type": "string",
                "title": "Callback URL",
                "description": "Public url that will receive notification on new emails",
                "minLength": 0,
                "default": "",
                "format": "uri",
                "pattern": "^(https|http)://.*|",
            }
        },
    }
    TEMPLATE_CONTEXT["schema"] = schema

    if request.method == "OPTIONS":
        return Response({"schema": schema}, template_name="rest_framework_base.html")

    form = JSONSchemaForm(
        data=request.data or {"json": json.dumps(email_data)},
        schema=schema,
        options=schema_options,
        ajax=False,
    )

    TEMPLATE_CONTEXT["form"] = form
    if "delete" in request.data or request.method == 'DELETE':
        error = delete_email(email)
        if not error:
            return Response(status=302, headers={"location": "/"})
        form.add_error(None, error)
    elif request.method == "POST":
        if form.is_valid():
            r = client.patch(
                internal_data["url"],
                data={"callback_url": form.cleaned_data["json"]["callback_url"]},
            )
            if r.status_code == 200:
                return Response(status=302, headers={"location": email_data["url"]})
            else:
                for k, v in r.json().items():
                    if k in form.fields:
                        form.add_error(k, v)
                    else:
                        form.add_error(None, v)

    if request.accepted_renderer.format == "json":
        if form.errors:
            email_data = form.errors.get_json_data()
    return Response(email_data, template_name="email_detail.html")


def email_attachment_adapter(request, e, a):
    r = a
    r["attachment_url"] = request.build_absolute_uri(
        f"/{e['account']}/messages/{e['uuid']}/{a['index']}/{a['filename']}"
    )
    return r


def email_message_adapter(request, e):
    r = {}
    r["url"] = request.build_absolute_uri(
        "/" + e["account"] + f"/messages/{e['uuid']}/"
    )
    r["frm"] = e["frm"]
    r["to"] = e["to"]
    r["subject"] = e["subject"]
    r["text"] = e["text"]
    r["html"] = e["html"]
    r["attachments"] = [
        email_attachment_adapter(request, e, a) for a in e["attachments"]
    ]
    r["account"] = e["account"]
    r["created_at"] = e["created_at"]

    if "format" in request.query_params:
        r["url"] = r["url"] + "?format=" + request.query_params["format"]
    return r


def email_adapter(request, e):
    r = {}
    r["url"] = request.build_absolute_uri("/" + e["address"] + "/")
    r["address"] = e["address"]
    r["messages"] = request.build_absolute_uri("/" + e["address"] + "/messages/")
    r["message_count"] = e["message_count"]
    r["messege_length_sum"] = e["messege_length_sum"]
    r["callback_url"] = e["callback_url"]

    if request.query_params.get("format"):
        r["url"] = r["url"] + "?format=" + request.query_params["format"]
        r["messages"] = r["messages"] + "?format=" + request.query_params["format"]
    return r


def user_email_list(request, user_id):
    d = {}
    page = request.query_params.get("page")
    if page:
        d["page"] = page
    page_size = request.query_params.get("page_size", None)
    if page_size:
        d["page_size"] = page_size

    url = rf"/_emails/?user_id={user_id}&" + parse.urlencode(d)
    j = client.get(url).json()
    j = page_adapter(request, j, "/")
    j = page_result_adapter(request, j, email_adapter)
    return j


def user_email_detail(request, user_id, email_address):
    url = rf"/_emails/?user_id={user_id}&" + parse.urlencode(
        {"address": email_address}, safe="@"
    )
    print(url)
    j = client.get(url).json()
    if j["count"] == 1:
        return j["results"][0], email_adapter(request, j["results"][0])
    return None


def page_adapter(request, j, path):
    if j.get("next"):
        qs = parse.urlsplit(j["next"]).query
        qs_dict = parse.parse_qs(qs)
        qs_dict = dict((k, qs_dict[k]) for k in ("page", "page_size") if k in qs_dict)
        if request.query_params.get("format"):
            qs_dict["format"] = request.query_params["format"]
        j["next"] = (
            request.build_absolute_uri(path)
            + "?"
            + parse.urlencode(qs_dict, doseq=True)
        )
    if j.get("previous"):
        qs = parse.urlsplit(j["previous"]).query
        qs_dict = parse.parse_qs(qs)
        qs_dict = dict((k, qs_dict[k]) for k in ("page", "page_size") if k in qs_dict)
        if "format" in request.query_params:
            qs_dict["format"] = request.query_params["format"]
        j["previous"] = (
            request.build_absolute_uri(path)
            + "?"
            + parse.urlencode(qs_dict, doseq=True)
        )
    return j


def page_result_adapter(request, j, func):
    j["results"] = [func(request, r) for r in j.get("results", [])]
    return j


def get_current_usage(emails):
    num_addresses = len(emails)
    messege_length_sum = 0
    message_count = 0
    for e in emails:
        message_count = message_count + e["message_count"]
        messege_length_sum = messege_length_sum + e["messege_length_sum"]

    present = arrow.utcnow()
    return {
        "num_addresses": num_addresses,
        "message_count": message_count,
        "messege_length_sum": messege_length_sum,
        "current_billing_cycle": present.replace(
            hour=0, minute=0, second=0, microsecond=0
        ),
        "next_billing_cycle": present.replace(
            hour=0, minute=0, second=0, microsecond=0
        ).shift(hours=24),
        "sats_per_message": RATE["sats_per_message"],
        "sats_per_address": RATE["sats_per_address"],
        "sats_per_byte": RATE["sats_per_byte"],
        "sats_total": (
            Decimal(message_count * RATE["sats_per_message"])
            + Decimal(num_addresses * RATE["sats_per_address"])
            + Decimal(messege_length_sum * RATE["sats_per_byte"])
        ),
    }


def bill_users(request):
    if request["user"]["id"] != settings["OWNER"]["id"]:
        return Response("no")

    profiles = client.get("/_data?path__startswith=v2/profile")["json"]["results"]
    r = []
    for profile in profiles:
        r = r + [bill_user(profile)]
    return Response(json.dumps(r, indent=2), content_type="json")


def bill_user(profile):
    user_id = profile["url"].split("/")[-1]
    emails = user_email_list(user_id)
    current_usage = get_current_usage(emails)
    current_usage["current_billing_cycle"] = current_usage[
        "current_billing_cycle"
    ].timestamp
    current_usage["next_billing_cycle"] = current_usage["next_billing_cycle"].timestamp
    r = client.post(
        r"/_data",
        data=json.loads(
            json.dumps(
                {
                    "path": rf'v1/transactions/{user_id}/{ current_usage["current_billing_cycle"] }',
                    "data": {
                        "amount": -current_usage["sats_total"],
                        "current_usage": current_usage,
                    },
                }
            )
        ),
    )
    return r["json"]


def static(request, path):
    r = client.get(f"/_data/static/{path}?format=file")
    # print(path)
    # print(f"/_data/static/{path}?format=file")
    if r.status_code == 200:
        return Response(
            r.content,
            content_type=r.content_type,
            headers={
                "Cache-Control": "public, max-age=31536001",
                "Expires": (datetime.now() + timedelta(days=10)).strftime(
                    "%a %d %b %Y %H:%M:%S%f GMT"
                ),
            },
        )
    return Response(r.content, status=404)


urls = [
    (r"/$", home),
    (r"/(?P<email_address>[^/]+@[^/]+.[^/])/$", email_detail_view),
    (r"/(?P<email_address>[^/]+@[^/]+.[^/])/messages/$", message_list_view),
    (
        r"/(?P<email_address>[^/]+@[^/]+.[^/])/messages/(?P<message_uuid>[^/]+)/$",
        message_detail_view,
    ),
    (
        r"/(?P<email_address>[^/]+@[^/]+.[^/])/messages/(?P<message_uuid>[^/]+)/(?P<attachment_index>[0-9]+)/(?P<filename>.+)$",
        attachment_detail,
    ),
    (r"/static/(?P<path>.*)$", static),
]


def handle(request):
    for path_re, view in urls:
        m = re2.match(path_re, request.path)
        if m:
            return view(request, **m.groupdict())

    for path_re, view in urls:
        m = re2.match(path_re, request.path + "/")
        if m:
            location = request.path + "/"
            if request.query_params:
                location = location + "?" + parse.urlencode(request.query_params)

            return Response(status=302, headers={"location": location})
    return Response({"content": "not found"}, status=404, template_name="base.html")


get = handle
post = handle
delete = handle

options = handle


# global store for things we want in the html, but are not the core data

TEMPLATE_CONTEXT = {}


def add_context(request):
    return TEMPLATE_CONTEXT


CONTEXT_PROCESSORS = [add_context]


def test_home():
    resp = handle({"path": "/", "user": {"username": "", "id": None}})
    resp = handle({"path": "/", "user": {"username": "bob2", "id": 2}})


def test_emails():
    resp = handle({"path": "/e/foo@example.com"})


def test_404():
    resp = handle({"path": "/non-existant"})


def test_http_error():
    resp = http_error({"some": "data"})
