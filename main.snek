# vim: syntax=python

from lazysignup.templatetags import lazysignup_tags
from django.urls import include, path, re_path
from functup import (
    print,
    Response,
    SnekTemplateHTMLRenderer,
    JSONRenderer,
    BrowsableAPIRenderer,
)
from rest_framework.decorators import api_view, renderer_classes

from uuid import uuid4
import base64
from functup import print, Response, FileResponse, get_channel, APIClient, settings
import html
from django_jsonforms.forms import JSONSchemaForm

from datetime import datetime, timedelta
import arrow
import simplejson as json
from decimal import Decimal
from time import monotonic
from urllib import parse
from requests.exceptions import HTTPError
import stripe
import re2
from io import BytesIO
from html import escape

client = APIClient()

BTC = Decimal(10 ** 8)

from btcpay import BTCPayClient
import os

UNLIMITED = "UNLIMITED"
FEATURES = {
    "personal": {"max_inboxes": 10, "callback": True},
    "pro": {"max_inboxes": 100, "callback": True},
    "enterprise": {"max_inboxes": 300, "custom_mx": True, "callback": True},
}

PLANS = {
    "basic30": {
        "name": "Basic",
        "features": FEATURES["personal"],
        "duration": {"days": 90},
        "price": {"USD": Decimal("10.00")},
    },
    "extra30": {
        "name": "Extra",
        "features": FEATURES["pro"],
        "duration": {"days": 90},
        "price": {"USD": Decimal("50.00")},
        "recommended": True,
    },
    "super30": {
        "name": "Super",
        "features": FEATURES["enterprise"],
        "duration": {"days": 90},
        "price": {"USD": Decimal("90.00")},
    },
}

# for p in PLANS:
#    PLANS[p]["price"]["sats"] = PLANS[p]["price"]["BTC"] * BTC


schema_options = {
    "required_by_default": True,
    "theme": "bootstrap4",
    "no_additional_properties": True,
    "disable_collapse": True,
    "disable_edit_json": True,
    "disable_properties": True,
}


def delete_email(email):
    r2 = None
    r2 = client.delete(f"/_emails/{ email }/")
    if r2.status_code == 204:
        return None
    return {"error": [email, r2]}


def delete_message(email, message_uuid):
    r2 = None
    r2 = client.delete(f"/_emails/{ email }/msg/{ message_uuid }/")
    if r2.status_code == 204:
        return None
    return r2.content


def add_email(request):
    email = request.data.get("email").strip()
    user_id = request.user.id
    r = client.post("/_emails/", {"address": email, "user_id": user_id})
    if r.status_code == 201:
        return None
    return r.json()


def get_or_create_profile(user_id):
    path = f"v2/profile/{user_id}"

    profile_res = client.get(f"/_data/{path}")
    if profile_res.status_code == 404:
        data = {"user_id": user_id, "current_plan": None, "next_plan": None}
        profile_res = client.put(f"/_data/{path}", data={"data": data, "path": path})
        if profile_res.status_code != 201:
            1 / 0
    profile = profile_res.json()
    TEMPLATE_CONTEXT["balance"] = round(profile["data"].get("balance", 0), 2)
    TEMPLATE_CONTEXT["profile"] = profile
    return profile


def update_invoice(user_id, invoice_id):
    btcpayclient = BTCPayClient(
        host=os.environ["BTCPAYSERVER_HOST"],
        pem=os.environ["BTCPAYSERVER_PEM"],
        tokens={"merchant": os.environ["BTCPAYSERVER_TOKEN"]},
    )
    invoice = btcpayclient.get_invoice(invoice_id)
    amount = 0
    if invoice["status"] in ["complete", "confirmed"]:
        amount = Decimal(invoice["price"])

    return client.patch(
        fr"/_data/v1/transactions/{user_id}/{ invoice_id }",
        data={"data": {"user_id": user_id, "amount": amount, "invoice": invoice}},
    )


def topup_view(request):
    user_id = request.user.id
    if not user_id:
        return Response(
            {"content": "Unauthorized"}, status=401, template_name="401.html"
        )

    profile = get_or_create_profile(user_id)
    errors = {}

    schema = {
        "title": "Top up account",
        "type": "object",
        "properties": {"amount": {"type": "number", "title": "USD", "minimum": 0.01}},
    }
    if request.method == "OPTIONS":
        return Response({"schema": schema}, template_name="rest_framework_base.html")
    TEMPLATE_CONTEXT["schema"] = schema
    request_data = {}
    if isinstance(request.data, dict):
        request_data = request.data
    initial = None
    if "amount" in request.query_params:
        initial = {
            "json": json.dumps({"amount": float(request.query_params.get("amount"))})
        }
    print(initial)
    form = JSONSchemaForm(
        initial=initial,
        data=request.data and {"json": request_data.get("json", request_data)} or None,
        schema=schema,
        options=schema_options,
        ajax=False,
    )
    # form = JSONSchemaForm(
    #    initial={"json": json.dumps({"amount": request.query_params.get("amount")})},
    #    data=request.data or None,
    #    schema=schema,
    #    options=schema_options,
    #    ajax=False,
    # )

    TEMPLATE_CONTEXT["form"] = form

    data = {}
    if request.method == "POST":
        if form.is_valid():
            btcpayclient = BTCPayClient(
                host=os.environ["BTCPAYSERVER_HOST"],
                pem=os.environ["BTCPAYSERVER_PEM"],
                tokens={"merchant": os.environ["BTCPAYSERVER_TOKEN"]},
            )
            amount = form.cleaned_data["json"]["amount"]
            invoice = btcpayclient.create_invoice(
                {
                    "price": amount,
                    "currency": "USD",
                    "redirectURL": "https://" + os.environ["HOST"],
                    "itemDescription": "top up",
                    "notificationURL": rf"https://{os.environ['HOST']}/update_invoice/",
                }
            )
            client.post(
                r"/_data",
                data={
                    "path": rf'v1/transactions/{user_id}/{ invoice["id"] }',
                    "data": {"invoice": invoice, "user_id": user_id},
                },
            )
            data = {
                "invoice_url": invoice["url"],
                "invoice_id": invoice["id"],
                "expiration_time": invoice["expirationTime"],
                "addresses": invoice["addresses"],
            }
            if request.accepted_renderer.format == "html":
                return Response(status=303, headers={"Location": invoice["url"]})
            # r = client.patch(profile["url"], data={"data": profile["data"]})
            # if r.status_code == 200:

            #    data = invoice
            # else:
            #    data = j.json()
    new_invoices_res = client.get(
        f"/_data?path__startswith=v1/transactions/{ user_id }/&data__invoice__status=new"
    )
    new_invoices = [
        update_invoice(i["data"]["invoice"]["id"])
        for i in new_invoices_res.json()["results"]
    ]
    if request.accepted_renderer.format == "json":
        if form.errors:
            data = form.errors.get_json_data()
    if request.accepted_renderer.format == "html":
        if any(new_invoices):
            new_invoices_res = client.get(
                f"/_data?path__startswith=v1/transactions/{ user_id }/&data__invoice__status=new"
            )
            new_invoices = new_invoices_res.json()["results"]
            TEMPLATE_CONTEXT["new_invoices"] = new_invoices
    return Response(data, template_name="topup.html")


def update_invoice_view(request):
    invoice_id = request.data.get("id", None) or request.query_params.get(
        "invoice_id", "1111"
    )
    return Response(update_invoice(invoice_id))


def update_invoice(invoice_id):
    btcpayclient = BTCPayClient(
        host=os.environ["BTCPAYSERVER_HOST"],
        pem=os.environ["BTCPAYSERVER_PEM"],
        tokens={"merchant": os.environ["BTCPAYSERVER_TOKEN"]},
    )
    data = None
    try:
        invoice = btcpayclient.get_invoice(invoice_id)
        r = client.get(f"/_data?data__invoice__id={ invoice_id }")
        if r.status_code == 200 and r.json()["count"] == 1:
            d = r.json()
            transaction = r.json()["results"][0]
            transaction["data"]["invoice"] = invoice
            # transaction["data"]["amount_sats"] = int(Decimal(invoice["btcPaid"]) * BTC)
            transaction["data"]["amount_usd"] = float(invoice["price"])
            r = client.patch(transaction["url"], data=transaction)
            data = invoice

    except Exception as e:
        print("Oh no")
        print(e)
    return data


STATIC_URL = "/static/"


def faq(request):
    """
    # Some questions you may also have
    """
    faqs = {
        "How do I use my own domain?": f"First purchase the correct plan, then you will need to add an MX record pointing to mx.mailpipe.io and a TXT record with a value 'func=mailpipe&user={ request.user.id or 'USER_ID'}'",
        "Can I use Mailpipe directly from Tor?": f"Absolutely, all Functup sites automatically are accessable from Tor as well. Mailpipe is availiable at https://mailpipe.{ settings['TOR_DOMAIN'] }.",
        "How can I pay with Lightning?": "Connect to our LND node: 0214b87e06039a44b5a23580f0e2f801b913fe9e3dc29169419f5eed15e449e9d3@35.243.77.241:9735",
        "Can I pay over Tor?": "Sure, connect to our Tor LND node: fafumon6bsuvs7rchggboh5il4byab5ccin7q353i6rj7ww6fengcsqd.onion:9735",
    }

    return Response({"faqs": faqs}, template_name="faq.html")


def welcome(request):
    """Welcome, this is the API documentation for Mailpipe"""
    if not request.is_tor and (request.get_host() != os.environ["HOST"]):
        return Response(
            status=301, headers={"location": "https://" + os.environ["HOST"]}
        )

    data = {"welcome": "This is the JSON view of the welcome page", "plans": PLANS}
    return Response(data, template_name="index.html")


def email_list(request):
    """
    Get your token from [https://functup.com](https://functup.com)

        $ TOKEN=...

    ## Create a new Inbox

        $ $ADDRESS=foo@mailpipe.io
        $ curl -H "Authorization: Token db229d7d71ada67ab1259af81b7c336f659d8081" -d address=$ADDRESS -d callback_url="" https://mailpipe.io


    
        $ curl -H "Authorization: Token $TOKEN" https://mailpipe.io/

    ## [List all Inboxes](/?format=api)

    
        $ TOKEN=111111111111111111
        $ curl -H "Authorization: Token $TOKEN" https://mailpipe.io/


    ## Retrieve an Inbox

        $ TOKEN=111111111111111111
    
        $ curl -H "Authorization: Token $TOKEN" https://mailpipe.io/$ADDRESS/
    

    ## Delete an Inbox

    You can delete an inbox with the `DELETE` method or by POSTing `delete` in form or json data

    
        $ curl -L -H "Authorization: Token $TOKEN" -X DELETE https://mailpipe.io/$ADDRESS/

        # OR
    
        $ curl -L -H "Authorization: Token $TOKEN" -d delete=1 https://mailpipe.io/$ADDRESS/

        # or

        $ curl -L -H "Authorization: Token $TOKEN"  -H "Content-Type: application/json" -d '{"delete": true}'  https://mailpipe.io/$ADDRESS/

    """

    if not request.is_tor and (request.get_host() != os.environ["HOST"]):
        return Response(
            status=301, headers={"location": "https://" + os.environ["HOST"]}
        )
    user_id = request.user.id
    if not user_id:
        return Response(status=307, headers={"Location": "/welcome/"})
    # should only be one but you never know
    profile = get_or_create_profile(user_id)
    errors = {}
    # next_page = f"/_data?data__owner={request.user.username}&path__startswith=v1/emails&page_size=10000"
    # next_page = False
    # while next_page:
    #    old_data_resp = client.get(next_page)
    #    old_address_list = old_data_resp.json()["results"]
    #    for oa in old_address_list:
    #        r = client.patch(f"/_emails/{oa['data']['email']}/", {"user_id": user_id})
    #        client.delete(oa["url"])
    #    next_page = old_data_resp.json()["next"]

    data = user_email_list(request, user_id)
    schema = {
        "title": "Create new inbox",
        "type": "object",
        "format": "grid",
        "properties": {
            "address": {
                "type": "string",
                "title": "Inbox email address",
                "description": "Email address you want to receive email.",
                "format": "email",
                "pattern": r"^[\w-]+@([\w-]+\.)+[\w-]+$",
                "minLength": 1,
            },
            "callback_url": {
                "type": "string",
                "title": "Callback URL",
                "description": "Public url that will receive notification on new emails",
                "minLength": 0,
                "default": "",
                "format": "uri",
                "pattern": "^(https|http)://.*|^$",
            },
        },
        "required": ["address", "callback_url"],
    }
    TEMPLATE_CONTEXT["schema"] = schema
    if request.method == "OPTIONS":
        return Response({"schema": schema}, template_name="rest_framework_base.html")

    request_data = None
    if request.method == "POST":
        request_data = {}
        if isinstance(request.data, dict):
            request_data = {"json": request.data.get("json", request.data or {"a": 1})}
        else:
            request_data = {"json": request.data}
    print(request_data)
    form = JSONSchemaForm(
        initial=request.data
        or {"json": json.dumps({"address": "@" + os.environ["HOST"]})},
        data=request_data,
        schema=schema,
        options=schema_options,
        ajax=False,
    )
    TEMPLATE_CONTEXT["form"] = form
    if request.method == "POST":
        if form.is_valid():
            print("form is valid")
            if (
                data["count"]
                < (
                    profile["data"].get("current_plan", None)
                    or {"features": {"max_inboxes": 1}}
                )["features"]["max_inboxes"]
            ):
                r = client.post(
                    "/_emails/",
                    data={
                        "callback_url": form.cleaned_data["json"]["callback_url"],
                        "address": form.cleaned_data["json"]["address"],
                        "user_id": user_id,
                    },
                )
                if r.status_code == 201:
                    email_data = email_adapter(request, r.json())
                    return Response(status=303, headers={"Location": email_data["url"]})
                else:
                    for k, v in r.json().items():
                        if k in form.fields:
                            form.add_error(k, v)
                        else:
                            form.add_error(None, v)
            else:
                form.add_error(
                    None,
                    "You have used all your avalible inboxes. Please upgrade your plan or delete an existing inbox.",
                )

    if request.accepted_renderer.format in ["json", "api"]:
        if form.errors:
            data = form.errors.form.errors.get_json_data()
            print(data)
    status = 200
    if form.errors:
        status = 400
    return Response(data, status=status, template_name="email_list.html")


def attachment_detail(request, email_address, message_uuid, attachment_index, filename):
    if not request.user.id:
        return Response(
            f"""<html><a href="/_login?next={ request.path }"> Log in required.</a>"""
        )

    user_id = request.user.id
    url = rf"/_emails/?user_id={user_id}&" + parse.urlencode(
        {"address": email_address}, safe="@"
    )
    j = client.get(url).json()
    if not j["count"] != "1":
        return Response("ohno, not found", status=404)
    message = client.get(f"/_emails/{email_address}/msg/{message_uuid}/").json()
    attachment = message["attachments"][int(attachment_index)]

    r = client.get(
        f"/_emails/{email_address}/msg/{message_uuid}/attachments/{attachment_index}/{filename}"
    )
    if r.status_code == 200:
        return Response(
            r.content,
            content_type=r["content-type"],
            headers={
                "Cache-Control": "public, max-age=31536001",
                "Expires": (datetime.now() + timedelta(days=10)).strftime(
                    "%a %d %b %Y %H:%M:%S%f GMT"
                ),
            },
        )
    return Response(r.content, status=404)


def message_list_view(request, email_address):
    if not request.user.id:
        return Response(
            f"""<html><a href="/_login?next={ request.path }"> Log in required.</a>"""
        )
    user_id = request.user.id
    url = rf"/_emails/?user_id={user_id}&" + parse.urlencode(
        {"address": email_address}, safe="@"
    )
    j = client.get(url).json()
    if not j["count"] != "1":
        return Response("uh oh, not found", status=404)
    email_data = j["results"][0]
    TEMPLATE_CONTEXT["email"] = email_data
    d = {}
    page = request.query_params.get("page")
    if page:
        d["page"] = page
    page_size = request.query_params.get("page_size", None)
    if page_size:
        d["page_size"] = page_size

    url = email_data["messages"] + "?" + parse.urlencode(d)
    j = client.get(url).json()
    j = page_adapter(request, j, f"/{email_address}/messages/")
    j = page_result_adapter(request, j, email_message_adapter)
    return Response(j, template_name="message_list.html")


def message_detail_view(request, email_address, message_uuid):
    if not request.user.id:
        return Response(
            f"""<html><a href="/_login?next={ request.path }"> Log in required.</a>"""
        )

    user_id = request.user.id
    url = rf"/_emails/?user_id={user_id}&" + parse.urlencode(
        {"address": email_address}, safe="@"
    )
    j = client.get(url).json()
    if j["count"] != 1:
        return Response("ohno, not found", status=404)
    r = client.get(f"/_emails/{email_address}/msg/{message_uuid}/")
    message = r.json()
    if r.status_code != 200:
        return Response(
            message, status=r.status_code, template_name="message_detail.html"
        )
    if request.method == "DELETE" or "delete" in request.data:
        error = delete_message(email_address, message_uuid)
        if not error:
            # todo just show deleted confirmation
            return Response(
                status=303, headers={"location": fr"/{ email_address }/messages/"}
            )
        return Response(error)

    return Response(
        email_message_adapter(request, message), template_name="message_detail.html"
    )


def owns_email(user_id, email):
    email_resp = client.get(f"/_emails/{email}/")
    if email_resp["status_code"] != 200 or email_resp["json"]["user_id"] != user_id:
        return False
    return email_resp["json"]


def email_detail_view(request, email_address):
    """
    Get your token from [https://functup.com](https://functup.com)

        $ TOKEN=...

    ## [List all Inboxes](/?format=api)

    
        $ curl -H "Authorization: Token $TOKEN" https://mailpipe.io/


    ## Retrieve an Inbox

        $ ADDRESS=foo@mailpipe.io
        $ curl -H "Authorization: Token $TOKEN" https://mailpipe.io/$ADDRESS/
    

    ## Delete an Inbox

    You can delete an inbox with the `DELETE` method or by POSTing `delete` in form or json data

        $ curl -L -H "Authorization: Token $TOKEN" -X DELETE https://mailpipe.io/$ADDRESS/

        # OR
    
        $ curl -L -H "Authorization: Token $TOKEN" -d delete=1 https://mailpipe.io/$ADDRESS/

        # or

        $ curl -L -H "Authorization: Token $TOKEN"  -H "Content-Type: application/json" -d '{"delete": true}'  https://mailpipe.io/$ADDRESS/

    """

    user_id = request.user.id
    if not user_id:
        return Response(
            {"content": "Unauthorized"}, status=401, template_name="base.html"
        )

    url = rf"/_emails/?user_id={user_id}&" + parse.urlencode(
        {"address": email_address}, safe="@"
    )
    j = client.get(url).json()
    if j["count"] == 1:
        internal_data = j["results"][0]
        email_data = email_adapter(request, internal_data)
    else:
        return Response("not found", status=404)

    schema = {
        "title": "Update Email settings",
        "type": "object",
        "properties": {
            "callback_url": {
                "type": "string",
                "title": "Callback URL",
                "description": "Public url that will receive notification on new emails",
                "minLength": 0,
                "default": "",
                "format": "uri",
                "pattern": "^(https|http)://.*|",
            }
        },
    }
    TEMPLATE_CONTEXT["schema"] = schema

    if request.method == "OPTIONS":
        return Response({"schema": schema}, template_name="rest_framework_base.html")

    form = JSONSchemaForm(
        data=request.data or {"json": json.dumps(email_data)},
        schema=schema,
        options=schema_options,
        ajax=False,
    )

    TEMPLATE_CONTEXT["form"] = form
    if "delete" in request.data or request.method == "DELETE":
        error = delete_email(email_address)
        if not error:
            return Response(
                {"deleted": email_address}, template_name="email_address_deleted.html"
            )
        else:
            form.add_error(None, error)
    elif request.method == "POST":
        if form.is_valid():
            r = client.patch(
                internal_data["url"],
                data={"callback_url": form.cleaned_data["json"]["callback_url"]},
            )
            if r.status_code == 200:
                return Response(status=303, headers={"location": email_data["url"]})
            else:
                for k, v in r.json().items():
                    if k in form.fields:
                        form.add_error(k, v)
                    else:
                        form.add_error(None, v)

    if request.accepted_renderer.format == "json":
        if form.errors:
            email_data = form.errors.get_json_data()
    return Response(email_data, template_name="email_detail.html")


def email_attachment_adapter(request, e, a):
    r = a
    r["attachment_url"] = request.build_absolute_uri(
        f"/{e['account']}/messages/{e['uuid']}/{a['index']}/{a['filename']}"
    )
    return r


def email_message_adapter(request, e):
    r = {}
    r["url"] = request.build_absolute_uri(
        "/" + e["account"] + f"/messages/{e['uuid']}/"
    )
    r["frm"] = e["frm"]
    r["to"] = e["to"]
    r["subject"] = e["subject"]
    r["text"] = e["text"]
    r["html"] = e["html"]
    r["attachments"] = [
        email_attachment_adapter(request, e, a) for a in e["attachments"]
    ]
    r["account"] = e["account"]
    r["created_at"] = e["created_at"]

    if "format" in request.query_params:
        r["url"] = r["url"] + "?format=" + request.query_params["format"]
    return r


def email_adapter(request, e):
    r = {}
    r["url"] = request.build_absolute_uri("/" + e["address"] + "/")
    r["address"] = e["address"]
    r["messages"] = request.build_absolute_uri("/" + e["address"] + "/messages/")
    r["message_count"] = e.get("message_count")
    r["messege_length_sum"] = e.get("messege_length_sum")
    r["callback_url"] = e["callback_url"]

    if request.query_params.get("format"):
        r["url"] = r["url"] + "?format=" + request.query_params["format"]
        r["messages"] = r["messages"] + "?format=" + request.query_params["format"]
    return r


def user_email_list(request, user_id):
    d = {}
    page = request.query_params.get("page")
    if page:
        d["page"] = page
    page_size = request.query_params.get("page_size", None)
    if page_size:
        d["page_size"] = page_size

    url = rf"/_emails/?user_id={user_id}&" + parse.urlencode(d)
    j = client.get(url).json()
    j = page_adapter(request, j, "/")
    j = page_result_adapter(request, j, email_adapter)
    return j


def user_email_detail(request, user_id, email_address):
    url = rf"/_emails/?user_id={user_id}&" + parse.urlencode(
        {"address": email_address}, safe="@"
    )
    j = client.get(url).json()
    if j["count"] == 1:
        return j["results"][0], email_adapter(request, j["results"][0])
    return None


def page_adapter(request, j, path):
    if j.get("next"):
        qs = parse.urlsplit(j["next"]).query
        qs_dict = parse.parse_qs(qs)
        qs_dict = dict((k, qs_dict[k]) for k in ("page", "page_size") if k in qs_dict)
        if request.query_params.get("format"):
            qs_dict["format"] = request.query_params["format"]
        j["next"] = (
            request.build_absolute_uri(path)
            + "?"
            + parse.urlencode(qs_dict, doseq=True)
        )
    if j.get("previous"):
        qs = parse.urlsplit(j["previous"]).query
        qs_dict = parse.parse_qs(qs)
        qs_dict = dict((k, qs_dict[k]) for k in ("page", "page_size") if k in qs_dict)
        if "format" in request.query_params:
            qs_dict["format"] = request.query_params["format"]
        j["previous"] = (
            request.build_absolute_uri(path)
            + "?"
            + parse.urlencode(qs_dict, doseq=True)
        )
    return j


def page_result_adapter(request, j, func):
    j["results"] = [func(request, r) for r in j.get("results", [])]
    return j


def static(request, path):
    r = client.get(f"/_data/static/{path}?format=file", format="file")
    if r.status_code == 200:
        return Response(
            r.content,
            content_type=r.content_type,
            headers={
                "Cache-Control": "public, max-age=31536001",
                "Expires": (datetime.now() + timedelta(days=10)).strftime(
                    "%a %d %b %Y %H:%M:%S%f GMT"
                ),
            },
        )
    return Response(r.content, status=404)


def transaction_adaptor(request, t):
    d = {
        "created": arrow.get(t["created"]).datetime,
        "updated": arrow.get(t["updated"]).datetime,
        "amount": Decimal(t["data"].get("amount_usd", 0)),
        "uuid": t["path"].split("/")[-1],
        "info": t.get("info", "no info"),
    }
    if "plan" in t["data"]:
        duration = list(t["data"]["plan"]["duration"].items())[0]
        d[
            "info"
        ] = f"Purchase  {t['data']['plan']['features']['max_inboxes'] } inbox(es) for { duration[1] } {duration[0]} "

    if "invoice" in t["data"]:
        d["info"] = "Balance topup"
        d["invoice_url"] = t["data"]["invoice"]["url"]
        d["invoice_id"] = t["data"]["invoice"]["id"]
        d["invoice_price"] = t["data"]["invoice"]["price"]
        d["status"] = t["data"]["invoice"]["status"]

    if "rebated_plan" in t["data"]:
        d["info"] = "Rebate for remaining time"

    return d


DOCS = {"name": "Mailpipe", "description": "A simple API for incoming email"}


def api_docs():
    return DOCS


def transaction_view(request):
    user_id = request.user.id
    if not user_id:
        return Response(
            {"content": "Unauthorized"}, status=401, template_name="base.html"
        )
    profile = get_or_create_profile(user_id)
    page = request.query_params.get("page", None)
    d = {}
    if page:
        d["page"] = page
    page_size = request.query_params.get("page_size", None)
    if page_size:
        d["page_size"] = page_size
    d["path__startswith"] = f"v1/transactions/{user_id}/"
    url = f"/_data?" + parse.urlencode(d)
    r = client.get(url)
    data = []
    if r.status_code == 200:
        data = r.json()

    balance = 0
    for t in data.get("results", []):
        balance = balance + t["data"].get("amount_usd", 0)

    profile["data"]["balance"] = balance
    client.patch(profile["url"], data={"data": profile["data"]})

    profile = get_or_create_profile(user_id)
    data = page_adapter(request, data, "/transactions/")
    data = page_result_adapter(request, data, transaction_adaptor)
    return Response(data, template_name="transaction_list.html")


def plan_view(request, selected_plan):
    if selected_plan not in PLANS:
        for k, p in PLANS.items():
            if p.get("recommended"):
                return Response(status=303, headers={"Location": f"/plans/{k}/"})
        return Response(status=303, headers={"Location": f"/plans/{k}/"})

    user_id = request.user.id
    if not user_id:
        if request.accepted_renderer.format == "html":
            return Response(
                status=303, headers={"Location": f"/_login?&next={request.path}"}
            )
        else:
            return Response(
                {"content": "Unauthorized"}, status=401, template_name="base.html"
            )
    data = {}
    profile = get_or_create_profile(user_id)
    schema = {
        "type": "object",
        "properties": {"plan": {"type": "string", "enum": list(PLANS.keys())}},
        "required": ["plan"],
    }
    TEMPLATE_CONTEXT["schema"] = schema
    TEMPLATE_CONTEXT["plans"] = PLANS
    present = arrow.utcnow()

    if request.method == "OPTIONS":
        return Response({"schema": schema}, template_name="rest_framework_base.html")

    rebate_amount = 0
    current_plan = profile["data"].get("current_plan", None)
    if current_plan:
        current_start = arrow.get(current_plan["start"])
        current_end = arrow.get(current_plan["end"])
        rebate_amount = Decimal(
            current_plan["price"].get("USD", 0)
            * ((current_end - present) / (current_end - current_start))
        )
    topup_needed = -min(
        0,
        Decimal(
            (Decimal(rebate_amount) + Decimal(profile["data"].get("balance", 0)))
            - PLANS[selected_plan]["price"]["USD"]
        ),
    )
    data["topup_needed"] = round(topup_needed, 2)
    data["rebate_amount"] = round(rebate_amount, 2)
    data["selected_plan"] = selected_plan
    data["plan"] = PLANS[selected_plan]

    request_data = {}
    if isinstance(request.data, dict):
        request_data = request.data

    form = JSONSchemaForm(
        data=request.data and {"json": request_data.get("json", request_data)} or None,
        schema=schema,
        options=schema_options,
        ajax=False,
    )

    TEMPLATE_CONTEXT["form"] = form

    if request.method == "POST":
        if form.is_valid():
            new_plan = PLANS[form.cleaned_data["json"]["plan"]]
            if rebate_amount + Decimal(profile["data"].get("balance", 0)) >= new_plan[
                "price"
            ]["USD"] * Decimal("0.9"):
                new_plan["start"] = present.isoformat()
                new_plan["end"] = present.shift(**new_plan["duration"]).isoformat()
                profile["data"]["current_plan"] = new_plan
                client.patch(profile["url"], data={"data": profile["data"]})

                # add rebate if needed
                if rebate_amount > 0:
                    r = client.post(
                        r"/_data",
                        data={
                            "path": rf"v1/transactions/{user_id}/{ uuid4() }",
                            "data": {
                                "amount_usd": rebate_amount,
                                "rebated_plan": current_plan,
                                "user_id": user_id,
                            },
                        },
                    )
                # make new current plan
                r = client.post(
                    r"/_data",
                    data={
                        "path": rf"v1/transactions/{user_id}/{ uuid4() }",
                        "data": {
                            "amount_usd": -new_plan["price"]["USD"],
                            "plan": new_plan,
                            "user_id": user_id,
                        },
                    },
                )
            else:
                form.add_error(None, "insufficient balance")

        else:
            data = form.errors.get_json_data()
    return Response(data=data, template_name="plans.html")


urls = [
    ("^/welcome/$", welcome),
    (r"^/$", email_list),
    (r"^/(?P<email_address>[^/]+@[^/]+.[^/])/$", email_detail_view),
    (r"^/(?P<email_address>[^/]+@[^/]+.[^/])/messages/$", message_list_view),
    (
        r"^/(?P<email_address>[^/]+@[^/]+.[^/])/messages/(?P<message_uuid>[^/]+)/$",
        message_detail_view,
    ),
    (
        r"^/(?P<email_address>[^/]+@[^/]+.[^/])/messages/(?P<message_uuid>[^/]+)/(?P<attachment_index>[0-9]+)/(?P<filename>.+)$",
        attachment_detail,
    ),
    (r"^/topup/$", topup_view),
    (r"^/transactions/$", transaction_view),
    (r"^/update_invoice/$", update_invoice_view),
    (r"^/plans/(?P<selected_plan>[a-z0-9]*)/$", plan_view),
    (r"^/static/(?P<path>.*)$", static),
]

urlpatterns = [
    re_path(
        "^faq/$",
        api_view(["GET"])(
            renderer_classes(
                [JSONRenderer, SnekTemplateHTMLRenderer, BrowsableAPIRenderer]
            )(faq)
        ),
    ),
    re_path(
        "^welcome/$",
        api_view(["GET"])(
            renderer_classes(
                [JSONRenderer, SnekTemplateHTMLRenderer, BrowsableAPIRenderer]
            )(welcome)
        ),
    ),
    re_path(
        r"^$",
        api_view(["GET", "POST"])(
            renderer_classes(
                [JSONRenderer, SnekTemplateHTMLRenderer, BrowsableAPIRenderer]
            )(email_list)
        ),
    ),
    re_path(
        r"^(?P<email_address>[^/]+@[^/]+.[^/])/$",
        api_view(["GET", "POST", "DELETE"])(
            renderer_classes(
                [JSONRenderer, SnekTemplateHTMLRenderer, BrowsableAPIRenderer]
            )(email_detail_view)
        ),
    ),
    re_path(
        r"^(?P<email_address>[^/]+@[^/]+.[^/])/messages/$",
        api_view(["GET"])(
            renderer_classes(
                [JSONRenderer, SnekTemplateHTMLRenderer, BrowsableAPIRenderer]
            )(message_list_view)
        ),
    ),
    re_path(
        r"^(?P<email_address>[^/]+@[^/]+.[^/])/messages/(?P<message_uuid>[^/]+)/$",
        api_view(["GET", "DELETE"])(
            renderer_classes(
                [JSONRenderer, SnekTemplateHTMLRenderer, BrowsableAPIRenderer]
            )(message_detail_view)
        ),
    ),
    re_path(
        r"^(?P<email_address>[^/]+@[^/]+.[^/])/messages/(?P<message_uuid>[^/]+)/(?P<attachment_index>[0-9]+)/(?P<filename>.+)$",
        api_view(["GET"])(
            renderer_classes(
                [JSONRenderer, SnekTemplateHTMLRenderer, BrowsableAPIRenderer]
            )(attachment_detail)
        ),
    ),
    re_path(
        r"^topup/$",
        api_view(["GET", "POST", "DELETE"])(
            renderer_classes([SnekTemplateHTMLRenderer])(topup_view)
        ),
    ),
    re_path(
        r"^transactions/$",
        api_view(["GET", "POST", "DELETE"])(
            renderer_classes([SnekTemplateHTMLRenderer])(transaction_view)
        ),
    ),
    re_path(
        r"^update_invoice/?$",
        api_view(["GET", "POST", "DELETE"])(
            renderer_classes([SnekTemplateHTMLRenderer])(update_invoice_view)
        ),
    ),
    re_path(
        r"^plans/(?P<selected_plan>[a-z0-9]*)/$",
        api_view(["GET", "POST"])(
            renderer_classes([SnekTemplateHTMLRenderer])(plan_view)
        ),
    ),
    re_path(
        r"^plans/$",
        api_view(["GET", "POST", "DELETE"])(
            renderer_classes([SnekTemplateHTMLRenderer])(plan_view)
        ),
        {"selected_plan": None},
    ),
    re_path(
        r"^static/(?P<path>.*)$",
        api_view(["GET"])(renderer_classes([SnekTemplateHTMLRenderer])(static)),
    ),
]


def handle(request):
    # if request.data and not isinstance(request.data, dict):
    #    return Response("Bad request", status=400, template_name="base.html")
    if not request.is_tor and (request.get_host() != os.environ["HOST"]):
        return Response(
            status=301, headers={"location": "https://" + os.environ["HOST"]}
        )

    for path_re, view in urls:
        m = re2.match(path_re, request.path)
        if m:
            response = view(request, **m.groupdict())
            # add format=api if this is an internal redirect an dthe original request had it
            if response.status_code in [301, 302, 303, 307, 308]:
                location = parse.urlsplit(response.get("location", ""))
                if not location.netloc:
                    if "format" in request.query_params:
                        location_qs = parse.parse_qs(location.query)
                        if "format" not in location_qs:
                            location_qs["format"] = request.query_params["format"]
                            new_location_query = parse.urlencode(
                                location_qs, doseq=True
                            )

                            response["location"] = parse.urlunsplit(
                                (
                                    location.scheme,
                                    location.netloc,
                                    location.path,
                                    new_location_query,
                                    location.fragment,
                                )
                            )

            return response

    for path_re, view in urls:
        m = re2.match(path_re, request.path + "/")
        if m:
            location = request.path + "/"
            if request.query_params:
                location = location + "?" + parse.urlencode(request.query_params)

            return Response(status=308, headers={"Location": location})
    return Response({"content": "not found"}, status=404, template_name="base.html")


get = handle
post = handle
delete = handle

options = handle


# global store for things we want in the html, but are not the core data

TEMPLATE_CONTEXT = {}

TEMPLATE_LIBRARIES = {"lazysignup_tags": lazysignup_tags.register}


def add_template_context(request):
    return TEMPLATE_CONTEXT


def add_user_context(request):
    return {"user": request.user}


def add_settings_context(request):
    return {"settings": settings}


CONTEXT_PROCESSORS = [add_template_context, add_user_context, add_settings_context]


def test_home():
    resp = handle({"path": "/", "user": {"username": "", "id": None}})
    resp = handle({"path": "/", "user": {"username": "bob2", "id": 2}})


def test_emails():
    resp = handle({"path": "/e/foo@example.com"})


def test_404():
    resp = handle({"path": "/non-existant"})
